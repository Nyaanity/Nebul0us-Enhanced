use crate::game::{enums, CONNECT_REQUEST_3, KEEP_ALIVE};
use crate::models::client::Instruction;
use crate::models::World;
use crate::net;
use async_trait::async_trait;
use rand::Rng;

#[derive(Default)]
pub struct Control {
    // Values are cached to recover the original values,
    // if necessary.
    speed: Option<u8>,
    cached_speed: Option<u8>,
    angle: Option<u16>,
    cached_angle: Option<u16>,
    eject_ct: Option<u32>,
    split_ct: Option<u32>,
    drop_ct: Option<u32>,
}

#[derive(Default)]
pub struct PlayerData<'a> {
    pub name: String,
    pub ticket: &'a str,
    pub skin: Option<enums::Skin>,
    pub rainbow_cycle: Option<enums::ColorCycle>,
    pub name_font: Option<enums::NameFont>,
    pub halo: Option<u8>,
    pub hat: Option<u8>,
    pub particle: Option<u8>,
    pub visibility: Option<enums::PlayerVisibility>,
    pub eject_skin: Option<u8>,
}

#[derive(Default)]
pub struct Net {
    pub connection_state: Option<enums::ConnectionState>,
    pub server_ip: String,
    pub server_port: u16,
    pub sock: Option<tokio::net::UdpSocket>,
    pub world: World,

    // Two tokens received from CONNECT_RESULT_2 (0x01).
    // Used to identify the client server-side.
    pub cr2_token1: Option<u32>,
    pub cr2_token2: Option<u32>,

    // Same as above, but randomly generated by ourselves.
    // These also need to be provided sometimes when
    // sending packets, e.g. DISCONNECT (0x07).
    pub rng_token1: u32,
    pub rng_token2: u32,
}

pub struct Bot<'a> {
    pub uniquifier: u8,
    pub controller_receiver: crossbeam_channel::Receiver<Instruction<'a>>,

    pub control: Control,
    pub player_data: PlayerData<'a>,
    pub net: Net,
}

impl<'a> Bot<'a> {
    pub fn new(
        bot_uniquifier: u8,
        controller_receiver: crossbeam_channel::Receiver<Instruction<'a>>,
        name: String,
        ticket: Option<&'a str>,
        server_ip: String,
    ) -> Self {
        let mut rng = rand::thread_rng();

        Bot {
            uniquifier: bot_uniquifier,
            controller_receiver,
            control: Control::default(),
            player_data: PlayerData {
                name,
                ticket: ticket.unwrap_or(",-"),
                ..Default::default() // TODO: implement customization
            },
            net: Net {
                server_ip,
                server_port: rng.gen_range(27900..=27901),
                rng_token1: rng.gen::<u32>(),
                rng_token2: rng.gen::<u32>(),
                world: World::default(),
                ..Default::default()
            },
        }
    }

    pub async fn setup_sock(&mut self) {
        let sock = tokio::net::UdpSocket::bind("0.0.0.0:0").await.unwrap();
        self.net.sock = Some(sock);
    }
}

#[async_trait]
pub trait BotFunx {
    async fn cheat_loop(&mut self);
}

#[async_trait]
impl<'a> BotFunx for Bot<'a> {
    async fn cheat_loop(&mut self) {
        self.setup_sock().await;
        CONNECT_REQUEST_3(self).await;

        let mut rand_range = rand::thread_rng().gen_range(2000000..=4000000);
        let current_timestamp = std::time::Instant::now();

        loop {
            net::recv_n_redirect(self).await;

            // send keep-alive every 2000000..=4000000 microseconds (2-4 seconds).
            // we have to keep the time so specific because this
            // fast af loop has no sleep function
            if current_timestamp.elapsed().as_micros() % rand_range == 0 {
                KEEP_ALIVE(self).await;
                rand_range = rand::thread_rng().gen_range(2000000..=4000000);
            }

            let received = self.controller_receiver.try_recv();

            if received.is_ok() {
                let received = received.unwrap();
                println!("Received: {} as bot {}", received.command, self.uniquifier);
            }
        }
    }
}
